syntax = "proto3";

package weshnet.protocol.v1;

option go_package = "berty.tech/weshnet/pkg/protocoltypes";

// ProtocolService is the top-level API to manage the Wesh protocol service.
// Each active Wesh protocol service is considered as a Wesh device and is associated with a Wesh user.
service ProtocolService {
  // ServiceExportData exports the current data of the protocol service
  rpc ServiceExportData (ServiceExportData.Request) returns (stream ServiceExportData.Reply);

  // ServiceGetConfiguration gets the current configuration of the protocol service
  rpc ServiceGetConfiguration (ServiceGetConfiguration.Request) returns (ServiceGetConfiguration.Reply);

  // ContactRequestReference retrieves the information required to create a reference (ie. included in a shareable link) to the current account
  rpc ContactRequestReference (ContactRequestReference.Request) returns (ContactRequestReference.Reply);

  // ContactRequestDisable disables incoming contact requests
  rpc ContactRequestDisable (ContactRequestDisable.Request) returns (ContactRequestDisable.Reply);

  // ContactRequestEnable enables incoming contact requests
  rpc ContactRequestEnable (ContactRequestEnable.Request) returns (ContactRequestEnable.Reply);

  // ContactRequestResetReference changes the contact request reference
  rpc ContactRequestResetReference (ContactRequestResetReference.Request) returns (ContactRequestResetReference.Reply);

  // ContactRequestSend attempt to send a contact request
  rpc ContactRequestSend (ContactRequestSend.Request) returns (ContactRequestSend.Reply);

  // ContactRequestAccept accepts a contact request
  rpc ContactRequestAccept (ContactRequestAccept.Request) returns (ContactRequestAccept.Reply);

  // ContactRequestDiscard ignores a contact request, without informing the other user
  rpc ContactRequestDiscard (ContactRequestDiscard.Request) returns (ContactRequestDiscard.Reply);

  // ShareContact uses ContactRequestReference to get the contact information for the current account and
  // returns the Protobuf encoding of a shareable contact which you can further encode and share. If needed, this
  // will reset the contact request reference and enable contact requests. To decode the result, see DecodeContact.
  rpc ShareContact (ShareContact.Request) returns (ShareContact.Reply);

  // DecodeContact decodes the Protobuf encoding of a shareable contact which was returned by ShareContact.
  rpc DecodeContact (DecodeContact.Request) returns (DecodeContact.Reply);

  // ContactBlock blocks a contact from sending requests
  rpc ContactBlock (ContactBlock.Request) returns (ContactBlock.Reply);

  // ContactUnblock unblocks a contact from sending requests
  rpc ContactUnblock (ContactUnblock.Request) returns (ContactUnblock.Reply);

  // ContactAliasKeySend send an alias key to a contact, the contact will be able to assert that your account is being present on a multi-member group
  rpc ContactAliasKeySend (ContactAliasKeySend.Request) returns (ContactAliasKeySend.Reply);

  // MultiMemberGroupCreate creates a new multi-member group
  rpc MultiMemberGroupCreate (MultiMemberGroupCreate.Request) returns (MultiMemberGroupCreate.Reply);

  // MultiMemberGroupJoin joins a multi-member group
  rpc MultiMemberGroupJoin (MultiMemberGroupJoin.Request) returns (MultiMemberGroupJoin.Reply);

  // MultiMemberGroupLeave leaves a multi-member group
  rpc MultiMemberGroupLeave (MultiMemberGroupLeave.Request) returns (MultiMemberGroupLeave.Reply);

  // MultiMemberGroupAliasResolverDisclose discloses your alias resolver key
  rpc MultiMemberGroupAliasResolverDisclose (MultiMemberGroupAliasResolverDisclose.Request) returns (MultiMemberGroupAliasResolverDisclose.Reply);

  // MultiMemberGroupAdminRoleGrant grants an admin role to a group member
  rpc MultiMemberGroupAdminRoleGrant (MultiMemberGroupAdminRoleGrant.Request) returns (MultiMemberGroupAdminRoleGrant.Reply);

  // MultiMemberGroupInvitationCreate creates an invitation to a multi-member group
  rpc MultiMemberGroupInvitationCreate (MultiMemberGroupInvitationCreate.Request) returns (MultiMemberGroupInvitationCreate.Reply);

  // AppMetadataSend adds an app event to the metadata store, the message is encrypted using a symmetric key and readable by future group members
  rpc AppMetadataSend (AppMetadataSend.Request) returns (AppMetadataSend.Reply);

  // AppMessageSend adds an app event to the message store, the message is encrypted using a derived key and readable by current group members
  rpc AppMessageSend (AppMessageSend.Request) returns (AppMessageSend.Reply);

  // GroupMetadataList replays previous and subscribes to new metadata events from the group
  rpc GroupMetadataList (GroupMetadataList.Request) returns (stream GroupMetadataEvent);

  // GroupMessageList replays previous and subscribes to new message events from the group
  rpc GroupMessageList (GroupMessageList.Request) returns (stream GroupMessageEvent);

  // GroupInfo retrieves information about a group
  rpc GroupInfo (GroupInfo.Request) returns (GroupInfo.Reply);

  // ActivateGroup explicitly opens a group
  rpc ActivateGroup (ActivateGroup.Request) returns (ActivateGroup.Reply);

  // DeactivateGroup closes a group
  rpc DeactivateGroup (DeactivateGroup.Request) returns (DeactivateGroup.Reply);

  // GroupDeviceStatus monitor device status
  rpc GroupDeviceStatus(GroupDeviceStatus.Request) returns (stream GroupDeviceStatus.Reply);

  rpc DebugListGroups (DebugListGroups.Request) returns (stream DebugListGroups.Reply);

  rpc DebugInspectGroupStore (DebugInspectGroupStore.Request) returns (stream DebugInspectGroupStore.Reply);

  rpc DebugGroup (DebugGroup.Request) returns (DebugGroup.Reply);

  rpc SystemInfo (SystemInfo.Request) returns (SystemInfo.Reply);

  // CredentialVerificationServiceInitFlow Initialize a credential verification flow
  rpc CredentialVerificationServiceInitFlow (CredentialVerificationServiceInitFlow.Request) returns (CredentialVerificationServiceInitFlow.Reply);

  // CredentialVerificationServiceCompleteFlow Completes a credential verification flow
  rpc CredentialVerificationServiceCompleteFlow (CredentialVerificationServiceCompleteFlow.Request) returns (CredentialVerificationServiceCompleteFlow.Reply);

  // VerifiedCredentialsList Retrieves the list of verified credentials
  rpc VerifiedCredentialsList (VerifiedCredentialsList.Request) returns (stream VerifiedCredentialsList.Reply);

  // ReplicationServiceRegisterGroup Asks a replication service to distribute a group contents
  rpc ReplicationServiceRegisterGroup (ReplicationServiceRegisterGroup.Request) returns (ReplicationServiceRegisterGroup.Reply);

  // PeerList returns a list of P2P peers
  rpc PeerList(PeerList.Request) returns (PeerList.Reply);

  // OutOfStoreReceive parses a payload received outside a synchronized store
  rpc OutOfStoreReceive(OutOfStoreReceive.Request) returns (OutOfStoreReceive.Reply);

  // OutOfStoreSeal creates a payload of a message present in store to be sent outside a synchronized store
  rpc OutOfStoreSeal(OutOfStoreSeal.Request) returns (OutOfStoreSeal.Reply);

  // RefreshContactRequest try to refresh the contact request for the given contact
  rpc RefreshContactRequest(RefreshContactRequest.Request) returns (RefreshContactRequest.Reply);
}


enum GroupType {
  // GroupTypeUndefined indicates that the value has not been set. For example, happens if group is replicated.
  GroupTypeUndefined = 0;

  // GroupTypeAccount is the group managing an account, available to all its devices.
  GroupTypeAccount = 1;

  // GroupTypeContact is the group created between two accounts, available to all their devices.
  GroupTypeContact = 2;

  // GroupTypeMultiMember is a group containing an undefined number of members.
  GroupTypeMultiMember = 3;

  // Following group types have not been defined, first is a group with
  // only approved writers, second is public group with anyone allowed to
  // write, in both cases full history is available to new members.
  //
  // GroupTypeChannel = 4;
  // GroupTypePublic = 5;
}

enum EventType {
  // EventTypeUndefined indicates that the value has not been set. Should not happen.
  EventTypeUndefined = 0;

  // EventTypeGroupMemberDeviceAdded indicates the payload includes that a member has added their device to the group
  EventTypeGroupMemberDeviceAdded = 1;

  // EventTypeGroupDeviceChainKeyAdded indicates the payload includes that a member has sent their device chain key to another member
  EventTypeGroupDeviceChainKeyAdded = 2;

  // EventTypeGroupAdditionalRendezvousSeedAdded adds a new rendezvous seed to a group
  // Might be implemented later, could be useful for replication services
  // EventTypeGroupAdditionalRendezvousSeedAdded = 3;

  // EventTypeGroupAdditionalRendezvousSeedRemoved removes a rendezvous seed from a group
  // Might be implemented later, could be useful for replication services
  // EventTypeGroupAdditionalRendezvousSeedRemoved = 4;

  // EventTypeAccountGroupJoined indicates the payload includes that the account has joined a group
  EventTypeAccountGroupJoined = 101;

  // EventTypeAccountGroupLeft indicates the payload includes that the account has left a group
  EventTypeAccountGroupLeft = 102;

  // EventTypeAccountContactRequestDisabled indicates the payload includes that the account has disabled incoming contact requests
  EventTypeAccountContactRequestDisabled = 103;

  // EventTypeAccountContactRequestEnabled indicates the payload includes that the account has enabled incoming contact requests
  EventTypeAccountContactRequestEnabled = 104;

  // EventTypeAccountContactRequestReferenceReset indicates the payload includes that the account has a new contact request rendezvous seed
  EventTypeAccountContactRequestReferenceReset = 105;

  // EventTypeAccountContactRequestOutgoingEnqueued indicates the payload includes that the account will attempt to send a new contact request
  EventTypeAccountContactRequestOutgoingEnqueued = 106;

  // EventTypeAccountContactRequestOutgoingSent indicates the payload includes that the account has sent a contact request
  EventTypeAccountContactRequestOutgoingSent = 107;

  // EventTypeAccountContactRequestIncomingReceived indicates the payload includes that the account has received a contact request
  EventTypeAccountContactRequestIncomingReceived = 108;

  // EventTypeAccountContactRequestIncomingDiscarded indicates the payload includes that the account has ignored a contact request
  EventTypeAccountContactRequestIncomingDiscarded = 109;

  // EventTypeAccountContactRequestIncomingAccepted indicates the payload includes that the account has accepted a contact request
  EventTypeAccountContactRequestIncomingAccepted = 110;

  // EventTypeAccountContactBlocked indicates the payload includes that the account has blocked a contact
  EventTypeAccountContactBlocked = 111;

  // EventTypeAccountContactUnblocked indicates the payload includes that the account has unblocked a contact
  EventTypeAccountContactUnblocked = 112;

  // EventTypeContactAliasKeyAdded indicates the payload includes that the contact group has received an alias key
  EventTypeContactAliasKeyAdded = 201;

  // EventTypeMultiMemberGroupAliasResolverAdded indicates the payload includes that a member of the group sent their alias proof
  EventTypeMultiMemberGroupAliasResolverAdded = 301;

  // EventTypeMultiMemberGroupInitialMemberAnnounced indicates the payload includes that a member has authenticated themselves as the group owner
  EventTypeMultiMemberGroupInitialMemberAnnounced = 302;

  // EventTypeMultiMemberGroupAdminRoleGranted indicates the payload includes that an admin of the group granted another member as an admin
  EventTypeMultiMemberGroupAdminRoleGranted = 303;

  // EventTypeGroupReplicating indicates that the group has been registered for replication on a server
  EventTypeGroupReplicating = 403;

  // EventTypeAccountVerifiedCredentialRegistered
  EventTypeAccountVerifiedCredentialRegistered = 500;

  // EventTypeGroupMetadataPayloadSent indicates the payload includes an app specific event, unlike messages stored on the message store it is encrypted using a static key
  EventTypeGroupMetadataPayloadSent = 1001;
}

// Account describes all the secrets that identifies an Account
message Account {
  // group specifies which group is used to manage the account
  Group group = 1;

  // account_private_key, private part is used to signs handshake, signs device, create contacts group keys via ECDH -- public part is used to have a shareable identity
  bytes account_private_key = 2;

  // alias_private_key, private part is use to derive group members private keys, signs alias proofs, public part can be shared to contacts to prove identity
  bytes alias_private_key = 3;

  // public_rendezvous_seed, rendezvous seed used for direct communication
  bytes public_rendezvous_seed = 4;
}

// Group define a group and is enough to invite someone to it
message Group {
  // public_key is the identifier of the group, it signs the group secret and the initial member of a multi-member group
  bytes public_key = 1;

  // secret is the symmetric secret of the group, which is used to encrypt the metadata
  bytes secret = 2;

  // secret_sig is the signature of the secret used to ensure the validity of the group
  bytes secret_sig = 3;

  // group_type specifies the type of the group, used to determine how device chain key is generated
  GroupType group_type = 4;

  // sign_pub is the signature public key used to verify entries, not required when secret and secret_sig are provided
  bytes sign_pub = 5;

  // link_key is the secret key used to exchange group updates and links to attachments, useful for replication services
  bytes link_key = 6;

  // link_key_sig is the signature of the link_key using the group private key
  bytes link_key_sig = 7;
}

message GroupHeadsExport {
  // public_key is the identifier of the group, it signs the group secret and the initial member of a multi-member group
  bytes public_key = 1;

  // sign_pub is the signature public key used to verify entries
  bytes sign_pub = 2;

  // metadata_heads_cids are the heads of the metadata store that should be restored from an export
  repeated bytes metadata_heads_cids = 3;

  // messages_heads_cids are the heads of the metadata store that should be restored from an export
  repeated bytes messages_heads_cids = 4;

  // link_key
  bytes link_key = 5;
}

// GroupMetadata is used in GroupEnvelope and only readable by invited group members
message GroupMetadata {
  // event_type defines which event type is used
  EventType event_type = 1;

  // the serialization depends on event_type, event is symmetrically encrypted
  bytes payload = 2;

  // sig is the signature of the payload, it depends on the event_type for the used key
  bytes sig = 3;

  // protocol_metadata is protocol layer data
  ProtocolMetadata protocol_metadata = 4;
}

// GroupEnvelope is a publicly exposed structure containing a group metadata event
message GroupEnvelope {
  // nonce is used to encrypt the message
  bytes nonce = 1;

  // event is encrypted using a symmetric key shared among group members
  bytes event = 2;

  reserved 3; // repeated bytes encrypted_attachment_cids = 3 ;
}

// MessageHeaders is used in MessageEnvelope and only readable by invited group members
message MessageHeaders {
  // counter is the current counter value for the specified device
  uint64 counter = 1;

  // device_pk is the public key of the device sending the message
  bytes device_pk = 2;

  // sig is the signature of the encrypted message using the device's private key
  bytes sig = 3;

  // metadata allow to pass custom informations
  map<string, string> metadata = 4;
}

message ProtocolMetadata {
  // attachments_secrets is a list of secret keys used retrieve attachments
  reserved 1; //repeated bytes attachments_secrets = 1;
}

// EncryptedMessage is used in MessageEnvelope and only readable by groups members that joined before the message was sent
message EncryptedMessage {
  // plaintext is the app layer data
  bytes plaintext = 1;

  // protocol_metadata is protocol layer data
  ProtocolMetadata protocol_metadata = 2;
}

// MessageEnvelope is a publicly exposed structure containing a group secure message
message MessageEnvelope {
  // message_headers is an encrypted serialization using a symmetric key of a MessageHeaders message
  bytes message_headers = 1;

  // message is an encrypted message, only readable by group members who previously received the appropriate chain key
  bytes message = 2;

  // nonce is a nonce for message headers
  bytes nonce = 3;

  // encrypted_attachment_cids is a list of attachment CIDs encrypted specifically for replication services
  reserved 4; // repeated bytes encrypted_attachment_cids = 4;
}

// ***************************************************************************
// Group event types
// ***************************************************************************

// EventContext adds context (its id, its parents and its attachments) to an event
message EventContext {
  // id is the CID of the underlying OrbitDB event
  bytes id = 1;

  // id are the the CIDs of the underlying parents of the OrbitDB event
  repeated bytes parent_ids = 2;

  // group_pk receiving the event
  bytes group_pk = 3;

  // attachment_cids is a list of attachment that can be retrieved
  reserved 4; // repeated bytes attachment_cids = 4;
}

// GroupMetadataPayloadSent is an app defined message, accessible to future group members
message GroupMetadataPayloadSent {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // message is the payload
  bytes message = 2;
}

// ContactAliasKeyAdded is an event type where ones shares their alias public key
message ContactAliasKeyAdded {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // alias_pk is the alias key which will be used to verify a contact identity
  bytes alias_pk = 2;
}

// GroupMemberDeviceAdded is an event which indicates to a group a new device (and eventually a new member) is joining it
// When added on AccountGroup, this event should be followed by appropriate GroupMemberDeviceAdded and GroupDeviceChainKeyAdded events
message GroupMemberDeviceAdded {
  // member_pk is the member sending the event
  bytes member_pk = 1;

  // device_pk is the device sending the event, signs the message
  bytes device_pk = 2;

  // member_sig is used to prove the ownership of the member pk
  bytes member_sig = 3; // TODO: signature of what ??? ensure it can't be replayed
}

// DeviceChainKey is a chain key, which will be encrypted for a specific member of the group
message DeviceChainKey {
  // chain_key is the current value of the chain key of the group device
  bytes chain_key = 1;

  // counter is the current value of the counter of the group device
  uint64 counter = 2;
}

// GroupDeviceChainKeyAdded is an event which indicates to a group member a device chain key
message GroupDeviceChainKeyAdded {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // dest_member_pk is the member who should receive the secret
  bytes dest_member_pk = 2;

  // payload is the serialization of Payload encrypted for the specified member
  bytes payload = 3;
}

// MultiMemberGroupAliasResolverAdded indicates that a group member want to disclose their presence in the group to their contacts
message MultiMemberGroupAliasResolverAdded {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // alias_resolver allows contact of an account to resolve the real identity behind an alias (Multi-Member Group Member)
  // Generated by both contacts and account independently using: hmac(aliasPK, GroupID)
  bytes alias_resolver = 2;

  // alias_proof ensures that the associated alias_resolver has been issued by the right account
  // Generated using aliasSKSig(GroupID)
  bytes alias_proof = 3;
}

// MultiMemberGroupAdminRoleGranted indicates that a group admin allows another group member to act as an admin
message MultiMemberGroupAdminRoleGranted {
  // device_pk is the device sending the event, signs the message, must be the device of an admin of the group
  bytes device_pk = 1;

  // grantee_member_pk is the member public key of the member granted of the admin role
  bytes grantee_member_pk = 2;
}

// MultiMemberGroupInitialMemberAnnounced indicates that a member is the group creator, this event is signed using the group ID private key
message MultiMemberGroupInitialMemberAnnounced {
  // member_pk is the public key of the member who is the group creator
  bytes member_pk = 1;
}

// GroupAddAdditionalRendezvousSeed indicates that an additional rendezvous point should be used for data synchronization
message GroupAddAdditionalRendezvousSeed {
  // device_pk is the device sending the event, signs the message, must be the device of an admin of the group
  bytes device_pk = 1;

  // seed is the additional rendezvous point seed which should be used
  bytes seed = 2;
}

// GroupRemoveAdditionalRendezvousSeed indicates that a previously added rendezvous point should be removed
message GroupRemoveAdditionalRendezvousSeed {
  // device_pk is the device sending the event, signs the message, must be the device of an admin of the group
  bytes device_pk = 1;

  // seed is the additional rendezvous point seed which should be removed
  bytes seed = 2;
}

// AccountGroupJoined indicates that the account is now part of a new group
message AccountGroupJoined {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // group describe the joined group
  Group group = 2;
}

// AccountGroupLeft indicates that the account has left a group
message AccountGroupLeft {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // group_pk references the group left
  bytes group_pk = 2;
}

// AccountContactRequestDisabled indicates that the account should not be advertised on a public rendezvous point
message AccountContactRequestDisabled {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;
}

// AccountContactRequestEnabled indicates that the account should be advertised on a public rendezvous point
message AccountContactRequestEnabled {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;
}

// AccountContactRequestReferenceReset indicates that the account should be advertised on different public rendezvous points
message AccountContactRequestReferenceReset {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // public_rendezvous_seed is the new rendezvous point seed
  bytes public_rendezvous_seed = 2;
}

// This event should be followed by an AccountGroupJoined event
// This event should be followed by a GroupMemberDeviceAdded event within the AccountGroup
// This event should be followed by a GroupDeviceChainKeyAdded event within the AccountGroup
// AccountContactRequestOutgoingEnqueued indicates that the account will attempt to send a contact request when a matching peer is discovered
message AccountContactRequestOutgoingEnqueued {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // group_pk is the 1to1 group with the requested user
  bytes group_pk = 2;

  // contact is a message describing how to connect to the other account
  ShareableContact contact = 3;

  // own_metadata is the identifying metadata that will be shared to the other account
  bytes own_metadata = 4;
}

// AccountContactRequestOutgoingSent indicates that the account has sent a contact request
message AccountContactRequestOutgoingSent {
  // device_pk is the device sending the account event, signs the message
  bytes device_pk = 1;

  // contact_pk is the contacted account
  bytes contact_pk = 2;
}

// AccountContactRequestIncomingReceived indicates that the account has received a new contact request
message AccountContactRequestIncomingReceived {
  // device_pk is the device sending the account event (which received the contact request), signs the message
  bytes device_pk = 1;

  // contact_pk is the account sending the request
  bytes contact_pk = 2;

  // TODO: is this necessary?
  // contact_rendezvous_seed is the rendezvous seed of the contact sending the request
  bytes contact_rendezvous_seed = 3;

  // TODO: is this necessary?
  // contact_metadata is the metadata specific to the app to identify the contact for the request
  bytes contact_metadata = 4;
}

// AccountContactRequestIncomingDiscarded indicates that a contact request has been refused
message AccountContactRequestIncomingDiscarded {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // contact_pk is the contact whom request is refused
  bytes contact_pk = 2;
}

// This event should be followed by an AccountGroupJoined event
// This event should be followed by GroupMemberDeviceAdded and GroupDeviceChainKeyAdded events within the AccountGroup
// AccountContactRequestIncomingAccepted indicates that a contact request has been accepted
message AccountContactRequestIncomingAccepted {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // contact_pk is the contact whom request is accepted
  bytes contact_pk = 2;

  // group_pk is the 1to1 group with the requester user
  bytes group_pk = 3;
}

// AccountContactBlocked indicates that a contact is blocked
message AccountContactBlocked {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // contact_pk is the contact blocked
  bytes contact_pk = 2;
}

// AccountContactUnblocked indicates that a contact is unblocked
message AccountContactUnblocked {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // contact_pk is the contact unblocked
  bytes contact_pk = 2;
}

message GroupReplicating {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1;

  // authentication_url indicates which server has been used for authentication
  string authentication_url = 2;

  // replication_server indicates which server will be used for replication
  string replication_server = 3;
}

// ***************************************************************************
//  RPC methods inputs and outputs
// ***************************************************************************

message ServiceExportData {
  message Request {}
  message Reply {
    bytes exported_data = 1;
  }
}

message ServiceGetConfiguration {
  enum SettingState {
    Unknown = 0;
    Enabled = 1;
    Disabled = 2;
    Unavailable = 3;
  }
  message Request {}
  message Reply {
    // account_pk is the public key of the current account
    bytes account_pk = 1;

    // device_pk is the public key of the current device
    bytes device_pk = 2;

    // account_group_pk is the public key of the account group
    bytes account_group_pk = 3;

    // peer_id is the peer ID of the current IPFS node
    string peer_id = 4;

    // listeners is the list of swarm listening addresses of the current IPFS node
    repeated string listeners = 5;
    SettingState ble_enabled = 6;
    SettingState wifi_p2p_enabled = 7; // MultiPeerConnectivity for Darwin and Nearby for Android
    SettingState mdns_enabled = 8;
    SettingState relay_enabled = 9;
  }
}

message ContactRequestReference {
  message Request {}
  message Reply {
    // public_rendezvous_seed is the rendezvous seed used by the current account
    bytes public_rendezvous_seed = 1;

    // enabled indicates if incoming contact requests are enabled
    bool enabled = 2;
  }
}

message ContactRequestDisable {
  message Request {}
  message Reply {}
}

message ContactRequestEnable {
  message Request {}
  message Reply {
    // public_rendezvous_seed is the rendezvous seed used by the current account
    bytes public_rendezvous_seed = 1;
  }
}

message ContactRequestResetReference {
  message Request {}
  message Reply {
    // public_rendezvous_seed is the rendezvous seed used by the current account
    bytes public_rendezvous_seed = 1;
  }
}

message ContactRequestSend {
  message Request {
    // contact is a message describing how to connect to the other account
    ShareableContact contact = 1;

    // own_metadata is the identifying metadata that will be shared to the other account
    bytes own_metadata = 2;
  }
  message Reply {}
}

message ContactRequestAccept {
  message Request {
    // contact_pk is the identifier of the contact to accept the request from
    bytes contact_pk = 1;
  }

  message Reply {}
}

message ContactRequestDiscard {
  message Request {
    // contact_pk is the identifier of the contact to ignore the request from
    bytes contact_pk = 1;
  }

  message Reply {}
}

message ShareContact {
  message Request {}
  message Reply {
    // encoded_contact is the Protobuf encoding of the ShareableContact. You can further encode the bytes for sharing, such as base58 or QR code.
    bytes encoded_contact = 1;
  }
}

message DecodeContact {
  message Request {
    // encoded_contact is the Protobuf encoding of the shareable contact (as returned by ShareContact).
    bytes encoded_contact = 1;
  }
  message Reply {
    // shareable_contact is the decoded shareable contact.
    ShareableContact contact = 1;
  }
}

message ContactBlock {
  message Request {
    // contact_pk is the identifier of the contact to block
    bytes contact_pk = 1;
  }

  message Reply {}
}

message ContactUnblock {
  message Request {
    // contact_pk is the identifier of the contact to unblock
    bytes contact_pk = 1;
  }

  message Reply {}
}

message ContactAliasKeySend {
  message Request {
    // contact_pk is the identifier of the contact to send the alias public key to
    bytes group_pk = 1;
  }

  message Reply {}
}

message MultiMemberGroupCreate {
  message Request {}
  message Reply {
    // group_pk is the identifier of the newly created group
    bytes group_pk = 1;
  }
}

message MultiMemberGroupJoin {
  message Request {
    // group is the information of the group to join
    Group group = 1;
  }

  message Reply {}
}

message MultiMemberGroupLeave {
  message Request {
    bytes group_pk = 1;
  }

  message Reply {}
}

message MultiMemberGroupAliasResolverDisclose {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;
  }

  message Reply {}
}

message MultiMemberGroupAdminRoleGrant {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;

    // member_pk is the identifier of the member which will be granted the admin role
    bytes member_pk = 2;
  }

  message Reply {}
}

message MultiMemberGroupInvitationCreate {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;
  }

  message Reply {
    // group is the invitation to the group
    Group group = 1;
  }
}

message AppMetadataSend {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;

    // payload is the payload to send
    bytes payload = 2;

    // attachment_cids is a list of attachment cids
    reserved 3; // repeated bytes attachment_cids = 3;
  }

  message Reply {
    bytes cid = 1;
  }
}

message AppMessageSend {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;

    // payload is the payload to send
    bytes payload = 2;

    // attachment_cids is a list of attachment cids
    reserved 3; // repeated bytes attachment_cids = 3;
  }

  message Reply {
    bytes cid = 1;
  }
}

message GroupMetadataEvent {
  // event_context contains context information about the event
  EventContext event_context = 1;

  // metadata contains the newly available metadata
  GroupMetadata metadata = 2;

  // event_clear clear bytes for the event
  bytes event = 3;
}

message GroupMessageEvent {
  // event_context contains context information about the event
  EventContext event_context = 1;

  // headers contains headers of the secure message
  MessageHeaders headers = 2;

  // message contains the secure message payload
  bytes message = 3;
}

message GroupMetadataList {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;

    // since is the lower ID bound used to filter events
    // if not set, will return events since the beginning
    bytes since_id = 2;

    // since_now will list only new event to come
    // since_id must not be set
    bool since_now = 3;

    // until is the upper ID bound used to filter events
    // if not set, will subscribe to new events to come
    bytes until_id = 4;

    // until_now will not list new event to come
    // until_id must not be set
    bool until_now = 5;

    // reverse_order indicates whether the previous events should be returned in
    // reverse chronological order
    bool reverse_order = 6;
  }
}

message GroupMessageList {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;

    // since is the lower ID bound used to filter events
    // if not set, will return events since the beginning
    bytes since_id = 2;

    // since_now will list only new event to come
    // since_id must not be set
    bool since_now = 3;

    // until is the upper ID bound used to filter events
    // if not set, will subscribe to new events to come
    bytes until_id = 4;

    // until_now will not list new event to come
    // until_id must not be set
    bool until_now = 5;

    // reverse_order indicates whether the previous events should be returned in
    // reverse chronological order
    bool reverse_order = 6;
  }
}


message GroupInfo {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;

    // contact_pk is the identifier of the contact
    bytes contact_pk = 2;
  }

  message Reply {
    // group is the group invitation, containing the group pk and its type
    Group group = 1;

    // member_pk is the identifier of the current member in the group
    bytes member_pk = 2;

    // device_pk is the identifier of the current device in the group
    bytes device_pk = 3;
  }
}

message ActivateGroup {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;

    // local_only will open the group without enabling network interactions
    // with other members
    bool local_only = 2;
  }

  message Reply {
  }
}

message DeactivateGroup {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;
  }

  message Reply {
  }
}

message GroupDeviceStatus {
  enum Type {
    TypeUnknown = 0;
    TypePeerDisconnected = 1;
    TypePeerConnected = 2;
    TypePeerReconnecting = 3;
  }

  enum Transport {
    TptUnknown = 0;
    TptLAN = 1;
    TptWAN = 2;
    TptProximity = 3;
  }

  message Request {
    bytes group_pk = 1;
  }

  message Reply {
    message PeerConnected {
      string peer_id = 1;
      bytes device_pk = 2;
      repeated Transport transports = 3;
      repeated string maddrs = 4;
    }

    message PeerReconnecting {
      string peer_id = 1;
    }

    message PeerDisconnected {
      string peer_id = 1;
    }

    Type type = 1;
    bytes event = 2;
  }
}

message DebugListGroups {
  message Request {
  }

  message Reply {
    // group_pk is the public key of the group
    bytes group_pk = 1;

    // group_type is the type of the group
    GroupType group_type = 2;

    // contact_pk is the contact public key if appropriate
    bytes contact_pk = 3;
  }
}

message DebugInspectGroupStore {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;

    // log_type is the log to inspect
    DebugInspectGroupLogType log_type = 2;
  }

  message Reply {
    // cid is the CID of the IPFS log entry
    bytes cid = 1;

    // parent_cids is the list of the parent entries
    repeated bytes parent_cids = 2 ;

    // event_type metadata event type if subscribed to metadata events
    EventType metadata_event_type = 3;

    // device_pk is the public key of the device signing the entry
    bytes device_pk = 4;

    // payload is the un encrypted entry payload if available
    bytes payload = 6;
  }
}

message DebugGroup {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1;
  }

  message Reply {
    // peer_ids is the list of peer ids connected to the same group
    repeated string peer_ids = 1 ;
  }
}

enum DebugInspectGroupLogType {
  DebugInspectGroupLogTypeUndefined = 0;
  DebugInspectGroupLogTypeMessage = 1;
  DebugInspectGroupLogTypeMetadata = 2;

}

enum ContactState {
  ContactStateUndefined = 0;
  ContactStateToRequest = 1;
  ContactStateReceived = 2;
  ContactStateAdded = 3;
  ContactStateRemoved = 4;
  ContactStateDiscarded = 5;
  ContactStateBlocked = 6;
}

message ShareableContact {
  // pk is the account to send a contact request to
  bytes pk = 1;

  // public_rendezvous_seed is the rendezvous seed used by the account to send a contact request to
  bytes public_rendezvous_seed = 2;

  // metadata is the metadata specific to the app to identify the contact for the request
  bytes metadata = 3;
}

message ServiceTokenSupportedService {
  string service_type = 1;
  string service_endpoint = 2;
}

message ServiceToken {
  string token = 1;
  string authentication_url = 2 ;
  repeated ServiceTokenSupportedService supported_services = 3;
  int64 expiration = 4;
}

message CredentialVerificationServiceInitFlow {
  message Request {
    string service_url = 1;
    bytes public_key = 2;
    string link = 3;
  }
  message Reply {
    string url = 1;
    bool secure_url = 2;
  }
}

message CredentialVerificationServiceCompleteFlow {
  message Request {
    string callback_uri = 1;
  }
  message Reply {
    string identifier = 1;
  }
}

message VerifiedCredentialsList {
  message Request {
    string filter_identifier = 1;
    string filter_issuer = 2;
    bool exclude_expired = 3;
  }
  message Reply {
    AccountVerifiedCredentialRegistered credential = 1;
  }
}

message ReplicationServiceRegisterGroup {
  message Request{
    bytes group_pk = 1;
    string token = 2;
    string authentication_url = 3;
    string replication_server = 4;
  }
  message Reply{}
}

message ReplicationServiceReplicateGroup {
  message Request {
    Group group = 1;
  }
  message Reply {
    bool ok = 1;
  }
}

message SystemInfo {
  message Request {}
  message Reply {
    Process process = 1;
    P2P p2p = 2;
    OrbitDB orbitdb = 3;
    repeated string warns = 4;
  }

  message OrbitDB {
    ReplicationStatus account_metadata = 1;

    message ReplicationStatus {
      int64 progress = 1;
      int64 maximum = 2;
      int64 buffered = 3;
      int64 queued = 4;
    }
  }

  message P2P {
    int64 connected_peers = 1;
  }
  message Process {
    string version = 1;
    string vcs_ref = 2;
    int64 uptime_ms = 3;
    int64 user_cpu_time_ms = 10;
    int64 system_cpu_time_ms = 11;
    int64 started_at = 12;
    uint64 rlimit_cur = 13;
    int64 num_goroutine = 14;
    int64 nofile = 15;
    bool too_many_open_files = 16;
    int64 num_cpu = 17;
    string go_version = 18;
    string operating_system = 19;
    string host_name = 20;
    string arch = 21;
    uint64 rlimit_max = 22;
    int64 pid = 23;
    int64 ppid = 24;
    int64 priority = 25;
    int64 uid = 26;
    string working_dir = 27;
    string system_username = 28;
  }
}

message PeerList {
  message Request {}
  message Reply {
    repeated Peer peers = 1;
  }

  message Peer {
    // id is the libp2p.PeerID.
    string id = 1;

    // routes are the list of active and known maddr.
    repeated Route routes = 2;

    // errors is a list of errors related to the peer.
    repeated string errors = 3;

    // Features is a list of available features.
    repeated Feature features = 4;

    // MinLatency is the minimum latency across all the peer routes.
    int64 min_latency = 5;

    // IsActive is true if at least one of the route is active.
    bool is_active = 6;

    // Direction is the aggregate of all the routes's direction.
    Direction direction = 7;
  }

  message Route {
    // IsActive indicates whether the address is currently used or just known.
    bool is_active = 1;

    // Address is the multiaddress via which we are connected with the peer.
    string address = 2;

    // Direction is which way the connection was established.
    Direction direction = 3;

    // Latency is the last known round trip time to the peer in ms.
    int64 latency = 4;

    // Streams returns list of streams established with the peer.
    repeated Stream streams = 5;
  }

  message Stream {
    // id is an identifier used to write protocol headers in streams.
    string id = 1;
  }

  enum Feature {
    UnknownFeature = 0;
    WeshFeature = 1;
    BLEFeature = 2;
    LocalFeature = 3;
    TorFeature = 4;
    QuicFeature = 5;

  }
}

enum Direction {
  UnknownDir = 0;
  InboundDir = 1;
  OutboundDir = 2;
  BiDir = 3;
}

// Progress define a generic object that can be used to display a progress bar for long-running actions.
message Progress {
  string state = 1;
  string doing = 2;
  float progress = 3;
  uint64 completed = 4;
  uint64 total = 5;
  uint64 delay = 6;
}

message OutOfStoreMessage {
  bytes cid = 1;
  bytes device_pk = 2;
  fixed64 counter = 3;
  bytes sig = 4;
  fixed32 flags = 5;
  bytes encrypted_payload = 6;
  bytes nonce = 7;
}

message OutOfStoreMessageEnvelope {
  bytes nonce = 1;
  bytes box = 2;
  bytes group_reference = 3;
}

message OutOfStoreReceive {
  message Request {
    bytes payload = 1;
  }
  message Reply {
    OutOfStoreMessage message = 1;
    bytes cleartext = 2;
    bytes group_public_key = 3;
    bool already_received = 4;
  }
}

message OutOfStoreSeal {
  message Request {
    bytes cid = 1;
    bytes group_public_key = 2;
  }
  message Reply {
    bytes encrypted = 1;
  }
}

message AccountVerifiedCredentialRegistered {
  // device_pk is the public key of the device sending the message
  bytes device_pk = 1;

  bytes signed_identity_public_key = 2;

  string verified_credential = 3;

  int64 registration_date = 4;

  int64 expiration_date = 5;

  string identifier = 6;

  string issuer = 7;
}

message FirstLastCounters {
  uint64 first = 1;
  uint64 last = 2;
}

// OrbitDBMessageHeads is the payload sent on orbitdb to share peer's heads
message OrbitDBMessageHeads {
  message Box {
    string address = 1;
    bytes heads = 2;
    bytes device_pk = 3;
    bytes peer_id = 4;
  }

  // sealed box should contain encrypted Box
  bytes sealed_box = 2;

  // current topic used
  bytes raw_rotation = 3;
}

message RefreshContactRequest {
  message Peer {
    // id is the libp2p.PeerID.
    string id = 1;

    // list of peers multiaddrs.
    repeated string addrs = 2;
  }

  message Request {
    bytes contact_pk = 1;
    // timeout in second
    int64 timeout = 2;
  }

  message Reply {
    // peers found and successfully connected.
    repeated Peer peers_found = 1;
  }
}
